Le possibili operazioni che si fanno fra le matrici di un'immagine sono somma e prodotto:
- **Dalla somma fra 2 matrici** raster (immagini raster) posso ottenere la matrice risultante. Con la somma matriciale non ottengo un un risultato "interessante" perchè **non ottengo l'unione** fra le due immagini raster.
- Il **prodotto**, invece, mi da **un risultato molto più interessante**. Esso è riga per colonna. Per eseguire tale moltiplicazione matriciale è necessario che le colonne della prima matrice siano uguali al numero di righe della seconda matrice. Per esempio: 4x3 e 3x7 sono moltiplicabili perchè **i valori "medi" delle dimensioni sono uguali**

# <font color ="red">OPERAZIONI AFFINI</font>
Presa un'immagine, un'**operazione** **affine** lavora solo sulla **posizione dei singoli pixel**. Serve per spostare i pixel nella nuova immagine. Non cambiano l'aspetto dell'immagine ma solo la posizione dei pixel e solitamente si fa sempre con le 3x3.
>Sostanzialmente si calcola, pixel per pixel, la nuova posizione che l'immagine deve assumere.

![[Pasted image 20221026214110.png]]
### Procedura:
- Prendo un punto nella matrice di coordinate generiche $(v,w)$ e le metto in un **vettore riga** e con questo si vuole fare un'operazione;
- L'operazione vale per un solo pixel;
- Il numero di pixel non raddoppia perchè non aumento o diminuisco i pixel;
- **Scorro** tutti i pixel della matrice e dico dove andare a posizionare i nuovi pixel mediante le operazioni affini;
- Non è detto che nella matrice di output io abbia riempito tutti pixel.

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color ="blue">Identità </font>
![[Pasted image 20221026214727.png|350]]

Nel posto vuoto del vettore riga (?) metto 1 ottenendo:
![[Pasted image 20221026214634.png|200]]
così da poter fare il prodotto riga per colonna.
Il risultato ci da una posizione.
![[Pasted image 20221026214835.png|350]]
Dove:
- **x** è il risultato della nuova riga del nuovo pixel
- **y** è il risultato della nuova colonna del nuovo pixel
- **T** è la matrice
Quindi le nuove coordinate che ottengo si possono scrivere come sistema di equazioni:
![[Pasted image 20221026215030.png|150]]

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color ="blue">Zooming (riscalaggio) </font>
Con questa operazione si possono creare **pixel vuoti** ma che poi verranno sistemati con **l'interpolazione**.
![[Pasted image 20221026215233.png|350]]
Dove:
- **cx** e **cy** sono le **costanti** che permettono di **riscalare**
- cx lungo le **coordinate x** (righe)
- cy lungo le **coordinate y** (colonne). 
- se entrambe le costanti **sono uguali** a 2 allora raddoppiamo l'immagine (zoom);
- se $cx>1$ o $cy >1$ allora l'**immagine aumenta** su $x$ o $y$
- se $0<cx<1$ o $0<cy <1$ allora l'**immagine diminuisce** su $y$ o su $x$
**Risultato**:
![[Pasted image 20221026215604.png|350]]
**Output**: 
![[Pasted image 20221026215706.png|150]]

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color="blue">Rotazione</font>
*Anche in questo caso si possono creare pixel vuoti ma si sistema con l'interpolazione*.
Ruota la matrice prendendo il **perno** l'angolo in alto a sinistra, quindi l'**origine degli assi**.
> Una rotazione di 30° gradi vuol dire che ruota in senso antiorario.

$\theta$ sarà l'angolo di rotazione
![[Pasted image 20221026215959.png|350]]
**Risultato**:
![[Pasted image 20221026220351.png]]
**Output**: 
![[Pasted image 20221026220402.png|250]]

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color="blue">Traslazione</font>
![[Pasted image 20221026220459.png|350]]
**Risultato**:
![[Pasted image 20221026220601.png|450]]

**Output**:
![[Pasted image 20221026220622.png|250]]
- Si **sommano** se **tx** e **ty** **se sono positivi** e viceversa se sono negativi.
>***In caso si diano origini a risultato in numeri negativi, pezzi di immagini lì non esistono più e si perdono i pixel.*** 
>Se traslo un'immagine verso sinistra fino a -324930, non la vedo più e quindi perdo pixel.
>Per sistemare tale problema si possono fare dei blocchi `if` per vedere se si presentano indici negativi e quindi evitare tali operazioni.

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color ="blue">Shear (verticale)</font>
![[Pasted image 20221026220834.png|350]]

**Risultato**:
![[Pasted image 20221026220958.png|450]]

**Output**:
![[Pasted image 20221026221038.png|250]]


## <font color ="blue">Shear (orizzontale)</font>
![[Pasted image 20221026221205.png|350]]
**Risultato**:
![[Pasted image 20221026221153.png|450]]

**Output**: 
![[Pasted image 20221026221227.png|250]]
# <font color ="red">FORWARD MAPPING</font>
Il fenomeno che crea buchi all'interno della nuova immagine è detto Forward Mapping
- $(v,w)$ è il pixel di input, $(x,y)$ quello di output e $T$ la matrice affine.
- Si applica l'operazione affine per ottenere il valore $[x \space y\space 1] = [v\space w\space 1] \times T$
- In questo caso **si fa scorrere l’immagine di input** e **per ogni pixel (v,w)** si calcola la posizione della nuova immagine (x,y)
- I risultati sono i seguenti:
![[Pasted image 20221020110112.png|450]]
![[Pasted image 20221020110121.png]]

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

# <font color ="red">INVERSE MAPPING </font>
Vediamo bene la formula del forward mapping.
![[Pasted image 20221020110137.png|200]]
>Questa formula crea i buchi. Allora scorro la matrice di output e per ogni pixel ci si pone la domanda "**quale valore devo copiare dall'input**?". 

Quindi, applicando l'inverse mapping, la formula diventa $[v \space w \space 1] = [x \space y \space1 \times inversa(T)]$

L'**output** allora è:
- $o(x,y) = A(v,w)$ con $A$ matrice di partenza.
![[Pasted image 20221020110612.png]]

<div style="page-break-after: always; visibility: hidden"> \pagebreak </div>

## <font color ="blue">Test su MATLAB</font>
![[Pasted image 20221020114614.png|550]]

### Osservazione:
- Le operazioni affini **non sono commutativi**.
# <font color="red">Combinazione di operazioni </font>
- In questo caso **faccio il prodotto riga per colonna** fra le matrici di cui devo eseguire le operazioni e **il risultato lo uso per fare le mie operazioni nella moltiplicazione per il vettore riga**.
- **L'ordine** del prodotto fra matrici **è importante** perchè **NON** si parla di operazioni commutative.